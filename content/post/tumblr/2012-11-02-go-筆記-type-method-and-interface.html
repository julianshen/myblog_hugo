---
date: "2012-11-02T21:33:26Z"
tags:
- IFTTT
- Blogger
title: '[Go 筆記] Type, method, and interface'
tumblr_url: http://blog.jln.co/post/34827660645/go-筆記-type-method-and-interface
---
<blockquote class="tr_bq"><b><i>&ldquo;Go was born out of frustration with existing languages and environments for systems programming.&rdquo;</i></b></blockquote>Go 是為了作為一個系統語言(systems programming language)而存在的, 它跟天下知名的C語言有同一個父親 - Ken Thompson , 作為一個系統語言, 它並不是直譯式語言, 也非跑在虛擬機(virtual machine)上, 而是貨真價實的像C一樣是先編譯(compile), 而且也是屬於strong and static type的語言, 這表示, 變數型別是預先宣告/決定的, 而且是不能半路變更的, 變數可以像這樣宣告:<br/><blockquote class="tr_bq"><i>var StrVariable string </i><br/><i>var IntVariable int</i></blockquote>這邊跟C, Java之類的語言不同的地方是, 型別定義是在後面不是放前面, 剛看到時我以為我會不習慣, 但卻花沒很多時間就適應了, 可能是我在很早以前寫過PASCAL的關係吧, PASCAL也是類似的寫法<br/><br/>但, Go其實還引入了一些dynamic language的特性, 因此在Go內也可以看到未經上面類型的宣告, 就直接指定的敘述, 像是:<br/><blockquote class="tr_bq"><i>strVariable2 := &ldquo;Hello Go&rdquo;</i></blockquote>這敘述並不代表Go也有dynamic typed的設計, 其實這設計是同時結合了宣告跟指定(assignment), strVariable2並不是沒有型別或動態型別, 因為&quot;:=&ldquo;的關係, 使得strVariable2一開始就被宣告成後面值的型別, 因此上面那行跟下面一樣:<br/><blockquote class="tr_bq"><i>var strVariable2 string </i><br/><i>strVariable2 = &quot;Hello Go&rdquo;</i></blockquote>同理, &ldquo;intVariable2 := 1&quot;這敘述表示intVariable一開始就被宣告成整數(因為1是整數), 所以它還是一個strong typed的設計, 這邊比較要注意到的一個陷阱是&rdquo;=&ldquo;和&rdquo;:=&ldquo;, 在已宣告過型別的變數, 是用正常的&rdquo;=&ldquo;來指定值, 但在未宣告的變數, 必須要用 &rdquo;:=&ldquo;<br/><br/>你不能做的是&hellip; &quot;strVariable2 = 1&rdquo;, 因為strVariable2在前面已經&quot;:=&ldquo;被宣告成字串(string)<br/><br/>在Go, 你一樣可以自定型別, 結構(struct)<br/><blockquote class="tr_bq"><i>type MyString string</i></blockquote><blockquote class="tr_bq"><i>type User struct {<br/>    Uid int<br/>    Name string<br/>} </i></blockquote>之後, 你就可以用MyString或是User來宣告變數, 像是<br/><blockquote class="tr_bq"><i>var M1 MyString<br/>var User1 User<br/>User2 := User {1, &quot;julian&rdquo;}</i></blockquote>&ldquo;type MyString string&quot;有點像是C語言的typedef, 可以讓你以另一個型別(MyString)來替代原本的型別(string), 但它其實還有個妙用, 在後面會再提到<br/><br/>Go是一個functional programming language, 所以它並<b>沒有物件導向</b>觀念<br/><br/>沒有&quot;類別&rdquo;(class), 沒有物件/實體(object/instance), 但, 它卻有&quot;方法&quot;(method)和&quot;介面&quot;(interface), 聽起來有點四不像, 但其實這部份還蠻有趣的<br/><br/>先說到&quot;方法&quot;(method), 在Go, 你可以為你的型別設計一個&quot;方法&quot;, 像是這樣:<br/><blockquote class="tr_bq"><i>func (u *User) Hi() {<br/>    fmt.Printf(&ldquo;Hi! I&rsquo;m %s. The %d user.\n&rdquo;, u.Uid, u.Name)<br/>}</i></blockquote>這邊&quot;Hi()&ldquo;就是屬於&quot;User&quot;的一個方法, 呼叫&quot;User2.Hi()&quot;即可執行它, 方法跟一般的函數一樣, 所不同的是, 前面多了一個&rdquo;(u *User)&ldquo; 以這例子來說, 這邊就是定義了&quot;Hi()&quot;的母體是 *User (*是指標- pointer的意思, 就不在這邊解釋)<br/><br/>這邊有趣的地方是, 你可以為任何自定型別創造&quot;方法&rdquo;, 包含函數(function), 這在&quot;net/http&quot;內就可以找到類似的應用:<br/><br/><script src="http://bit.ly/SkFh4m"></script><br/><br/>在這例子中, HandlerFunc有一個ServeHTTP的方法, 但HandlerFunc本身其實是一個function<br/><br/>&ldquo;介面&rdquo;(interface)也是一個蠻妙的東西, 在Java裡, interface必須要宣告&quot;實作&quot;, 亦即&quot;class MyImpl implements MyInterface&quot;, 也就是你必須指定某個class實作了某個interface<br/><br/>但在Go, 則是很不一樣, 在Go裡, 你可以宣告一個&quot;介面&quot;(interface) 像是<br/><blockquote class="tr_bq"><i>type MyInterface interface {<br/>    Foo()<br/>}</i></blockquote>但你不需要宣告某個型別&quot;實作&quot;了這個interface, 在Go, interface反而比較有&quot;暗示&quot;(imply)的意味, 也就是, 下面的例子, 不用任何宣告, 你可以把MyString自動當成它也可以是一個MyInterface:<br/><blockquote class="tr_bq"><i>func (s MyString) Foo() {</i><i>}</i></blockquote>因為在MyInterface的定義中, 它含有一個&quot;Foo()&ldquo;, 當你替MyString宣告了一個&quot;Foo()&quot;的方法時, 就自動讓MyString變成了一個實作了MyInterface的型別<br/><br/>下面用一個比較完整的例子來總結:<br/><script src="http://bit.ly/TyPcq5"></script><br/><br/>在這例子中, &quot;CallFoo(MyInterface)&quot;接受一個MyInterface的參數, 並執行它&quot;Foo()&quot;的方法, 由於&quot;Aa&rdquo;(字串)和&quot;MyHandler&quot;(函數)都是有一個&quot;Foo()&ldquo;的方法, 所以他們都可以被當做MyInterface作為參數, 同理, 回到前一個HandlerFunc範例, HandlerFunc其實也可以被當做Handler這個interface來使用, 在&quot;net/http&quot;的API中就是用到了這樣一個技巧<br/><br/><br/><br/>
via Blogger <a href="http://bit.ly/SkFhkC">http://bit.ly/SkFhkC</a>
